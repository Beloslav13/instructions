-- Вставка (добавление) данных в таблицу
INSERT INTO courses (name, slug, lessons_count, body)
  VALUES ('basics of programming', 'basics', 10, 'this is theory');

-- INSERT позволяет вставить сразу несколько записей в рамках одного запроса:
INSERT INTO courses (name, slug) VALUES
  ('Bash', 'bash'), ('PHP', 'php'), ('Ruby', 'ruby');

-- Обновление (изменение) данных
UPDATE courses SET body = 'updated!' WHERE slug = 'bash';
-- Обычно UPDATE запрос состоит из двух частей. В первой (там, где SET) описывается какое значение установить в какое поле. Во второй (той, что идёт после WHERE) указывается ограничение на то,
-- к каким строкам применить обновление.

-- За одну операцию можно обновить несколько полей. Для этого достаточно перечислить каждое присваивание через запятую в части SET. Порядок в котором изменяются поля — не важен:
UPDATE courses SET body = 'updated!', name = 'Bash' WHERE slug = 'bash';

-- Операции сравнения
UPDATE courses SET name = 'new name' WHERE lessons_count > 3;
UPDATE courses SET name = 'another new name' WHERE lessons_count < 2;

-- Логические операции
-- И
UPDATE courses SET name = 'new name'
  WHERE slug = 'bash' AND lessons_count > 3;

-- ИЛИ
UPDATE courses SET name = 'another new name'
  WHERE lessons_count < 2 OR lessons_count > 8;


-- Удаление данных
DELETE FROM courses WHERE slug = 'bash';

-- В базах данных есть ещё один способ удалять данные в таблице — TRUNCATE. Он не является частью стандарта, но реализован большинством баз данных. У него две особенности:
--	 1. Он предназначен для полной очистки таблиц.
--	 2. В отличие от DELETE, он выполняется очень эффективно так как у TRUNCATE нет возможности задавать условия, а значит СУБД не нужно ничего дополнительно анализировать.
--	 Она сразу очищает место на диске минуя все промежуточные этапы.
TRUNCATE courses;


-- После WHERE указывается имя поля, которое сравнивается с некоторым значением (это один из вариантов)
-- Выбираем всех пользователей, родившихся ранее 21 октября 2018 года
SELECT * FROM users WHERE birthday < '2018-10-21';

-- Использовать пейджинг на уровне базы данных:
SELECT * FROM users LIMIT 3;

-- Однако, SQL НЕ гарантирует никакого порядка в выборках выше. Если явно не указать сортировку, то мы не можем достоверно знать, в каком порядке вернутся данные.
-- Поэтому в подобных выборках всегда присутствует секция ORDER BY
SELECT * FROM users ORDER BY birthday;

-- Если нужно отсортировать в обратном порядке, то надо добавить ключевое слово DESC (англ. descending — "убывающий").
SELECT * FROM users ORDER BY birthday DESC;

-----------------------------------------


-- Первая нормальная форма сводится к трем правилам:

    -- Каждая ячейка таблицы может хранить только одно значение
    -- Все данные в одной колонке могут быть только одного типа
    -- Каждая запись в таблице должна однозначно отличаться от других записей

-- Реляционная модель требует от нас уникальности каждой записи. Для чего это нужно? Иначе невозможно понять что к чему
-- относится и с какой записью нужно работать при изменениях. Очень легко начать править не то и
-- потерять важную информацию. Причем мы даже не можем полагаться на порядок данных внутри таблицы, ведь он не гарантирован.

-- Реализовать уникальность можно несколькими способами, например, добавить новых полей, которые сделают запись уникальной,
-- например дату заказа. Этот способ не очень надежный, а главное не очень удобный в работе.
-- Придется постоянно анализировать весь набор полей. Гораздо лучше добавить первичный ключ.

-- Первичный ключ это поле или набор полей, которое содержит уникальное значение для каждой записи.
-- Первичный ключ не может меняться, его значение однозначно определяет любую запись в таблице.

-- В качестве первичного ключа можно использовать какое-то значение из окружающего мира, например email или ФИО,
-- но нужно однозначно убедиться что ключ не будет повторяться. Такой первичный ключ называется естественным.
-- Естественные ключи используют редко из-за их ненадежности. Почти наверняка они не уникальны и могут изменяться или повторяться.
-- Например, номер паспорта меняется при смене паспорта.

-- Другой подход основан на использовании автоматически генерируемых уникальных значений.
-- Такой первичный ключ называется суррогатным и поддерживается любой базой данных "из коробки".
-- Иногда это просто числа, а иногда и сложные число-буквенные строки (хеши). Например PRIMARY KEY - id.

-- Первичный ключ принято создавать первым полем с названием id. Для первичного ключа обязательно указывать PRIMARY KEY в описании таблицы:
-- Первичный ключ только один на таблицу
CREATE TABLE products (
    id bigint PRIMARY KEY,
    first_name varchar(255),
    last_name varchar(255),
    address varchar(255),
    item varchar(255),
    price numeric -- специальный тип данных, подходящий под работу с деньгами. Обеспечивает высокую точность при расчетах.
);
-- Такой ключ все еще нужно формировать самостоятельно (с автогенерацией мы познакомимся позже),
-- но теперь база данных сама следит за уникальностью. При попытке создать запись с повторяющимися первичными ключами возникнет ошибка.

CREATE TABLE users (
	id bigint NOT NULL PRIMARY KEY,
	first_name varchar(255),
	created_at timestamp
);

INSERT INTO users (id, first_name, created_at) VALUES (1, 'Vladislav', '2020-02-24');

CREATE TABLE orders (
	id bigint NOT NULL PRIMARY KEY,
	user_first_name varchar(255),
	months int,
	created_at timestamp
);

INSERT INTO orders (id, user_first_name, months, created_at) VALUES (1, 'Vladislav', 7, '2020-02-24');
INSERT INTO orders (id, user_first_name, months, created_at) VALUES (2, 'Vladislav', 3, '2020-02-25');


----------------------------------------------------

-- Вторая нормальная форма включает в себя два пункта:

    -- Таблица должна быть в первой нормальной форме
    -- Все атрибуты (не ключевые) таблицы должны зависеть от первичного ключа

-- Важно понимать, что внешний ключ — это не ссылка. Таблицы существуют сами по себе,
-- и во внешнем ключе указывается конкретное значение, которое должно совпадать с первичным ключом другой таблицы.

-- Синтаксис определения вторичного (внешнего) ключа:

-- REFERENCES <название таблицы на которую смотрим> (<список полей в той таблице, которым соответствуем>)

-- Внешних ключей может быть любое количество: сколько ссылок — столько и ключей
CREATE TABLE orders (
    id bigint PRIMARY KEY,
    -- Тип внешнего ключа должен быть такой же,
    -- как у первичного в той таблице, куда ссылается внешний
    user_id bigint REFERENCES users (id),
    -- остальные поля
);

-- Для чего это нужно? Таким образом автоматически поддерживаются гарантии корректности.
-- Например, невозможно удалить запись из основной таблицы, если на эту запись есть ссылки из внешних ключей в другой таблице.
-- Это очень важно для соблюдения целостности, чтобы случайно не завести базу данных в неконсистентное состояние
-- (то есть такое состояние, при котором данные ссылаются на несуществующие данные).

-- Третья нормальная форма, так же как и вторая, включает в себя два пункта:

-- Таблица должна быть во второй нормальной форме
-- Все колонки в таблице зависят от первичного ключа и не зависят друг от друга


----------------------------------------------------

-- Первичный ключ

-- Первичный ключ однозначно идентифицирует каждую запись внутри таблицы. Задаётся с помощью фразы PRIMARY KEY,
-- которая добавляется после указания типа при создании таблицы. Первичный ключ в таблице может быть только один и,
-- как правило, для него используется суррогатный ключ — идентификатор, который не имеет никакого физического смысла.

----------------------------------------------------

-- Внешний ключ

-- Это ограничение, которое связывает указанную колонку с данными из другой таблицы.
-- Такое ограничение гарантирует целостность данных. То есть попытка удалить данные, у которых есть зависимые данные, приведёт к ошибке.
CREATE TABLE orders (
    id bigint PRIMARY KEY,
    product_id integer REFERENCES products (id),
    quantity integer
);

-- Not Null
-- Это ограничение указывает на то, что колонка не может содержать null значения.
-- Его можно комбинировать с другими ограничениями, например, внешними ключами. Первичный ключ является NOT NULL по умолчанию.
CREATE TABLE products (
    id bigint PRIMARY KEY,
    name text NOT NULL,
    price numeric
);
CREATE TABLE orders (
    id bigint PRIMARY KEY,
    product_id integer REFERENCES products (id) NOT NULL,
    quantity integer
);


----------------------------------------------------

-- Уникальность
-- Для гарантии уникальности значений одного поля используется ключевое слово UNIQUE. Обычно его используют в описании конкретного поля при создании таблицы:
CREATE TABLE products (
    id bigint PRIMARY KEY,
    name text UNIQUE,
    price numeric
);
-- UNIQUE никогда не используется совместно с первичным ключом, так как он уникален по определению.
-- Иногда бывает нужно реализовать уникальность по двум или более атрибутам. Для этого нужно описать UNIQUE отдельно от конкретного поля:
CREATE TABLE products (
    id bigint PRIMARY KEY,
    name text,
    locale varchar,
    price numeric,
    UNIQUE(name, locale)
);
-- Существует ситуация, в которой ограничение уникальности не срабатывает.
-- Такое происходит, если хотя бы в одном из столбцов, включенных в ограничение, встречается NULL. По стандарту, NULL никогда не равен сам себе.


----------------------------------------------------

-- Изменение структуры таблицы (ALTER)

-- Добавление колонки
-- в таблице "courses"
-- добавить колонку с именем "example1" и типом "timestamp"
ALTER TABLE courses ADD COLUMN example1 timestamp;

-- Переименование колонки

-- в таблице "courses"
-- изменить колонку "example1":
-- поменять имя с "example1" на "example2"
ALTER TABLE courses RENAME COLUMN example1 TO example2;

-- Удаление колонки

-- в таблице "courses"
-- удалить колонку с именем "example2"
ALTER TABLE courses DROP COLUMN example2;

-- Обновление колонки

ALTER TABLE addresses
    ADD PRIMARY KEY (id);

ALTER TABLE addresses
    ALTER COLUMN created_at SET DATA TYPE timestamp,
    ALTER COLUMN street DROP NOT NULL;

-- Добавление уникального индекса в таблицу "products" для колонки "product_id"
ALTER TABLE products ADD UNIQUE (product_id);

-- Наиболее распространённые команды:

    -- ADD — добавление ограничения: например, ключа или уникальности
    -- SET — установка значения: например, типа данных
    -- DROP — удаление ограничения
    -- Запрос ALTER устроен таким образом, что в рамках одного обновления можно группировать только одинаковые операции.
    -- В примере выше как раз это показано: один запрос добавляет первичный ключ, а другой обновляет сразу два поля.
    -- Если попробовать объединить их в один ALTER, то СУБД завершит запрос с ошибкой.


----------------------------------------------------

-- Сортировка.
-- Сортировка задаётся с помощью части ORDER BY, за которой следует имя поля, по которому происходит сортировка:
SELECT * FROM users ORDER BY username;

-- База данных — умная штука, она знает, как сравнивать не только числа, но и строки, и даты.
-- Сортировка по датам — крайне частая операция, выглядит она идентично любой другой сортировке:
SELECT * FROM users ORDER BY created_at;

-- Если ничего дополнительно не указывать, то ORDER BY сортирует в прямом порядке — от меньшего к большему.
-- Запрос выше — это сокращённая версия полного запроса с сортировкой: полный запрос включает в себя ASC,
-- который подставляется автоматически, если ничего не указано:

SELECT * FROM users ORDER BY created_at ASC;
-- то же самое что и SELECT * FROM users ORDER BY created_at;

-- Для сортировки в обратном порядке указывается DESC:
SELECT * FROM users ORDER BY created_at DESC;

-- Иногда возникает необходимость сортировать данные сразу по нескольким полям.
-- Этого легко добиться, просто перечисляя поля через запятую:
SELECT * FROM users ORDER BY first_name, created_at;

-- Порядок сортировки в таком случае задаётся для каждого поля индивидуально:
SELECT * FROM users ORDER BY first_name DESC, created_at DESC;
SELECT first_name, created_at FROM users ORDER BY first_name ASC, created_at DESC;

-- У сортировки есть один тонкий момент, связанный с сортировкой полей, содержащих NULL.
-- Если ничего не указано дополнительно, то считается, что NULL больше любого значения.
-- Другими словами, при прямой сортировке они окажутся в конце выборки, а при обратной — в начале.
-- Этим поведением можно управлять с помощью фразы NULLS FIRST:
-- сортируем по возрастанию даты (поле "created_at")
-- поведение по умолчанию:
-- поля, содержащие NULL, идут последними
SELECT * FROM users ORDER BY created_at ASC;

-- сортируем по возрастанию даты (поле "created_at")
-- поля, содержащие NULL, идут первыми
SELECT * FROM users ORDER BY created_at ASC NULLS FIRST;

-- сортируем по убыванию даты (поле "created_at")
-- поля, содержащие NULL, идут последними
SELECT * FROM users ORDER BY created_at DESC NULLS LAST;



----------------------------------------------------

-- Условия (WHERE)
-- Самое простое условие — указание прямого соответствия. Например, выборка по идентификатору:
-- В случае базы данных знак `=` должен восприниматься
-- как математическое равенство, а не присваивание.
SELECT * FROM users WHERE id = 3;

UPDATE users SET first_name = 'Valya' WHERE id = 3;

DELETE FROM users WHERE id = 3;

-- выбрать всех пользователей с идентификатором, НЕ равным трём
SELECT * FROM users WHERE id != 3;

-- Проверка на равенство с NULL
-- Равно NULL:
SELECT * FROM users WHERE first_name IS NULL;
-- Не равно NULL:
SELECT * FROM users WHERE created_at IS NOT NULL;

-- Равенство строк
SELECT * FROM users WHERE first_name = 'sunny';
SELECT * FROM users WHERE first_name = 'Sunny';
-- Выше два разных запроса.
-- По этой причине данные в базе стараются хранить в нормализованном виде. То есть, перед добавлением в БД их приводят,
-- например, к нижнему регистру, и то же самое делают при выборках. Классический пример — email.
-- Его нужно хранить только в нижнем регистре.
-- Кроме точного соответствия, SQL поддерживает и все остальные операции сравнения: > (больше), < (меньше), != (не равно),
-- >= (больше либо равно, "не меньше"), <= (меньше либо равно, "не больше").
SELECT *
  FROM users
  WHERE created_at < '2018-10-05';


----------------------------------------------------

-- Логические операторы
-- В свою очередь все операции можно объединять в цепочки, используя логические операторы OR и AND:
SELECT *
  FROM users
  WHERE created_at > '1998-10-05' AND created_at < '2018-10-05';

-- Для условий диапазонов SQL поддерживает особый формат BETWEEN:
SELECT *
  FROM users
  WHERE created_at BETWEEN '2018-01-01' AND '2018-10-05';
-- Идентично SELECT * FROM users WHERE created_at >= '2018-01-01' AND created_at <= '2018-10-05';

-- IN
SELECT * FROM users WHERE id = 1 OR id = 2 OR id = 5;

-- Страшно представить, во что превратится запрос, если понадобится найти десяток совпадений. К счастью, SQL предлагает другое решение - IN:
SELECT * FROM users WHERE id IN (1, 2, 5);

-- Иногда нужно искать по частичному совпадению: например, проверяя, что строка начинается или заканчивается с определённой
-- последовательности символов. Допустим, мы хотим посмотреть пользователей, имя которых начинается с буквы A:
SELECT * FROM users WHERE first_name LIKE 'A%';
-- Обратите внимание на то, что этот поиск регистрозависимый. Если вы хотите искать БЕЗ учёта регистра, то используйте ILIKE.


--------------------------------------------

-- Лимит (LIMIT)
SELECT * FROM users LIMIT 10;
-- А что, если пользователь, просмотрев первые 10 записей, захочет посмотреть следующие 10? Это обычная ситуация,
-- которая реализуется через пейджинг — специальный механизм, который позволяет перемещаться по страницам.
-- Для его реализации одного LIMIT не достаточно, также понадобится смещение OFFSET:
SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 10;


----------------------------------------------------


-- DISTINCT
-- Предположим, что нам нужно узнать все имена, которые есть у наших пользователей.
-- Самый простой способ сделать это — выполнить запрос не всех полей, а только имени:
-- получить список имён всех пользователей
SELECT first_name FROM users;

-- Избавиться от дублей можно с помощью DISTINCT.
SELECT DISTINCT first_name FROM users;
-- DISTINCT позволяет указывать не одно, а сразу несколько полей:
-- DISTINCT добавляется в запрос только один раз, независимо от того, сколько колонок перечисляется
SELECT DISTINCT first_name, last_name FROM users;

-- В эту выборку попадут все значения с уникальным сочетанием имён и фамилий. Это значит,
-- что имена и фамилии повторяться могут, но пара всегда уникальна. Если в DISTINCT добавить первичный ключ
-- (SELECT DISTINCT id, first_name FROM users), то запрос извлечёт все записи. Такой результат является следствием уникальности первичного ключа.


-- Все записи, уникальные по user_id
SELECT DISTINCT ON (user_id) * FROM topics;

 id | user_id |              title              | body                  |       created_at
----|---------|---------------------------------|-----------------------|------------------------
  2 |       2 | molestiae voluptas velit        | Quod quasi molestiae. | 2019-06-02 23:42:30.688

-- Все title для уникальных user_id
SELECT DISTINCT ON (user_id) title FROM topics;

             title
-------------------------
 molestiae voluptas velit

SELECT DISTINCT user_id, title FROM topics;
-- Такой запрос вернет совершенно другие данные, он вернет все уникальные пары user_id-title
-- То есть здесь возможно повторение user_id в результирующей выборке

SELECT DISTINCT ON (user_id, title) user_id, title FROM topics;
-- Этот запрос равносилен тому, что был выше


-------------------------------------------------