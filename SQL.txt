-- Вставка (добавление) данных в таблицу
INSERT INTO courses (name, slug, lessons_count, body)
  VALUES ('basics of programming', 'basics', 10, 'this is theory');

-- INSERT позволяет вставить сразу несколько записей в рамках одного запроса:
INSERT INTO courses (name, slug) VALUES
  ('Bash', 'bash'), ('PHP', 'php'), ('Ruby', 'ruby');

-- Обновление (изменение) данных
UPDATE courses SET body = 'updated!' WHERE slug = 'bash';
-- Обычно UPDATE запрос состоит из двух частей. В первой (там, где SET) описывается какое значение установить в какое поле. Во второй (той, что идёт после WHERE) указывается ограничение на то,
-- к каким строкам применить обновление.

-- За одну операцию можно обновить несколько полей. Для этого достаточно перечислить каждое присваивание через запятую в части SET. Порядок в котором изменяются поля — не важен:
UPDATE courses SET body = 'updated!', name = 'Bash' WHERE slug = 'bash';

-- Операции сравнения
UPDATE courses SET name = 'new name' WHERE lessons_count > 3;
UPDATE courses SET name = 'another new name' WHERE lessons_count < 2;

-- Логические операции
-- И
UPDATE courses SET name = 'new name'
  WHERE slug = 'bash' AND lessons_count > 3;

-- ИЛИ
UPDATE courses SET name = 'another new name'
  WHERE lessons_count < 2 OR lessons_count > 8;


-- Удаление данных
DELETE FROM courses WHERE slug = 'bash';

-- В базах данных есть ещё один способ удалять данные в таблице — TRUNCATE. Он не является частью стандарта, но реализован большинством баз данных. У него две особенности:
--	 1. Он предназначен для полной очистки таблиц.
--	 2. В отличие от DELETE, он выполняется очень эффективно так как у TRUNCATE нет возможности задавать условия, а значит СУБД не нужно ничего дополнительно анализировать.
--	 Она сразу очищает место на диске минуя все промежуточные этапы.
TRUNCATE courses;


-- После WHERE указывается имя поля, которое сравнивается с некоторым значением (это один из вариантов)
-- Выбираем всех пользователей, родившихся ранее 21 октября 2018 года
SELECT * FROM users WHERE birthday < '2018-10-21';

-- Использовать пейджинг на уровне базы данных:
SELECT * FROM users LIMIT 3;

-- Однако, SQL НЕ гарантирует никакого порядка в выборках выше. Если явно не указать сортировку, то мы не можем достоверно знать, в каком порядке вернутся данные.
-- Поэтому в подобных выборках всегда присутствует секция ORDER BY
SELECT * FROM users ORDER BY birthday;

-- Если нужно отсортировать в обратном порядке, то надо добавить ключевое слово DESC (англ. descending — "убывающий").
SELECT * FROM users ORDER BY birthday DESC;

-----------------------------------------


-- Первая нормальная форма сводится к трем правилам:

    -- Каждая ячейка таблицы может хранить только одно значение
    -- Все данные в одной колонке могут быть только одного типа
    -- Каждая запись в таблице должна однозначно отличаться от других записей

-- Реляционная модель требует от нас уникальности каждой записи. Для чего это нужно? Иначе невозможно понять что к чему
-- относится и с какой записью нужно работать при изменениях. Очень легко начать править не то и
-- потерять важную информацию. Причем мы даже не можем полагаться на порядок данных внутри таблицы, ведь он не гарантирован.

-- Реализовать уникальность можно несколькими способами, например, добавить новых полей, которые сделают запись уникальной,
-- например дату заказа. Этот способ не очень надежный, а главное не очень удобный в работе.
-- Придется постоянно анализировать весь набор полей. Гораздо лучше добавить первичный ключ.

-- Первичный ключ это поле или набор полей, которое содержит уникальное значение для каждой записи.
-- Первичный ключ не может меняться, его значение однозначно определяет любую запись в таблице.

-- В качестве первичного ключа можно использовать какое-то значение из окружающего мира, например email или ФИО,
-- но нужно однозначно убедиться что ключ не будет повторяться. Такой первичный ключ называется естественным.
-- Естественные ключи используют редко из-за их ненадежности. Почти наверняка они не уникальны и могут изменяться или повторяться.
-- Например, номер паспорта меняется при смене паспорта.

-- Другой подход основан на использовании автоматически генерируемых уникальных значений.
-- Такой первичный ключ называется суррогатным и поддерживается любой базой данных "из коробки".
-- Иногда это просто числа, а иногда и сложные число-буквенные строки (хеши). Например PRIMARY KEY - id.

-- Первичный ключ принято создавать первым полем с названием id. Для первичного ключа обязательно указывать PRIMARY KEY в описании таблицы:
-- Первичный ключ только один на таблицу
CREATE TABLE products (
    id bigint PRIMARY KEY,
    first_name varchar(255),
    last_name varchar(255),
    address varchar(255),
    item varchar(255),
    price numeric -- специальный тип данных, подходящий под работу с деньгами. Обеспечивает высокую точность при расчетах.
);
-- Такой ключ все еще нужно формировать самостоятельно (с автогенерацией мы познакомимся позже),
-- но теперь база данных сама следит за уникальностью. При попытке создать запись с повторяющимися первичными ключами возникнет ошибка.

CREATE TABLE users (
	id bigint NOT NULL PRIMARY KEY,
	first_name varchar(255),
	created_at timestamp
);

INSERT INTO users (id, first_name, created_at) VALUES (1, 'Vladislav', '2020-02-24');

CREATE TABLE orders (
	id bigint NOT NULL PRIMARY KEY,
	user_first_name varchar(255),
	months int,
	created_at timestamp
);

INSERT INTO orders (id, user_first_name, months, created_at) VALUES (1, 'Vladislav', 7, '2020-02-24');
INSERT INTO orders (id, user_first_name, months, created_at) VALUES (2, 'Vladislav', 3, '2020-02-25');


----------------------------------------------------

-- Вторая нормальная форма включает в себя два пункта:

    -- Таблица должна быть в первой нормальной форме
    -- Все атрибуты (не ключевые) таблицы должны зависеть от первичного ключа

-- Важно понимать, что внешний ключ — это не ссылка. Таблицы существуют сами по себе,
-- и во внешнем ключе указывается конкретное значение, которое должно совпадать с первичным ключом другой таблицы.

-- Синтаксис определения вторичного (внешнего) ключа:

-- REFERENCES <название таблицы на которую смотрим> (<список полей в той таблице, которым соответствуем>)

-- Внешних ключей может быть любое количество: сколько ссылок — столько и ключей
CREATE TABLE orders (
    id bigint PRIMARY KEY,
    -- Тип внешнего ключа должен быть такой же,
    -- как у первичного в той таблице, куда ссылается внешний
    user_id bigint REFERENCES users (id),
    -- остальные поля
);

-- Для чего это нужно? Таким образом автоматически поддерживаются гарантии корректности.
-- Например, невозможно удалить запись из основной таблицы, если на эту запись есть ссылки из внешних ключей в другой таблице.
-- Это очень важно для соблюдения целостности, чтобы случайно не завести базу данных в неконсистентное состояние
-- (то есть такое состояние, при котором данные ссылаются на несуществующие данные).

-- Третья нормальная форма, так же как и вторая, включает в себя два пункта:

-- Таблица должна быть во второй нормальной форме
-- Все колонки в таблице зависят от первичного ключа и не зависят друг от друга


----------------------------------------------------

-- Первичный ключ

-- Первичный ключ однозначно идентифицирует каждую запись внутри таблицы. Задаётся с помощью фразы PRIMARY KEY,
-- которая добавляется после указания типа при создании таблицы. Первичный ключ в таблице может быть только один и,
-- как правило, для него используется суррогатный ключ — идентификатор, который не имеет никакого физического смысла.

----------------------------------------------------

-- Внешний ключ

-- Это ограничение, которое связывает указанную колонку с данными из другой таблицы.
-- Такое ограничение гарантирует целостность данных. То есть попытка удалить данные, у которых есть зависимые данные, приведёт к ошибке.
CREATE TABLE orders (
    id bigint PRIMARY KEY,
    product_id integer REFERENCES products (id),
    quantity integer
);

-- Not Null
-- Это ограничение указывает на то, что колонка не может содержать null значения.
-- Его можно комбинировать с другими ограничениями, например, внешними ключами. Первичный ключ является NOT NULL по умолчанию.
CREATE TABLE products (
    id bigint PRIMARY KEY,
    name text NOT NULL,
    price numeric
);
CREATE TABLE orders (
    id bigint PRIMARY KEY,
    product_id integer REFERENCES products (id) NOT NULL,
    quantity integer
);


----------------------------------------------------

-- Уникальность
-- Для гарантии уникальности значений одного поля используется ключевое слово UNIQUE. Обычно его используют в описании конкретного поля при создании таблицы:
CREATE TABLE products (
    id bigint PRIMARY KEY,
    name text UNIQUE,
    price numeric
);
-- UNIQUE никогда не используется совместно с первичным ключом, так как он уникален по определению.
-- Иногда бывает нужно реализовать уникальность по двум или более атрибутам. Для этого нужно описать UNIQUE отдельно от конкретного поля:
CREATE TABLE products (
    id bigint PRIMARY KEY,
    name text,
    locale varchar,
    price numeric,
    UNIQUE(name, locale)
);
-- Существует ситуация, в которой ограничение уникальности не срабатывает.
-- Такое происходит, если хотя бы в одном из столбцов, включенных в ограничение, встречается NULL. По стандарту, NULL никогда не равен сам себе.


----------------------------------------------------

-- Изменение структуры таблицы (ALTER)

-- Добавление колонки
-- в таблице "courses"
-- добавить колонку с именем "example1" и типом "timestamp"
ALTER TABLE courses ADD COLUMN example1 timestamp;

-- Переименование колонки

-- в таблице "courses"
-- изменить колонку "example1":
-- поменять имя с "example1" на "example2"
ALTER TABLE courses RENAME COLUMN example1 TO example2;

-- Удаление колонки

-- в таблице "courses"
-- удалить колонку с именем "example2"
ALTER TABLE courses DROP COLUMN example2;

-- Обновление колонки

ALTER TABLE addresses
    ADD PRIMARY KEY (id);

ALTER TABLE addresses
    ALTER COLUMN created_at SET DATA TYPE timestamp,
    ALTER COLUMN street DROP NOT NULL;

-- Добавление уникального индекса в таблицу "products" для колонки "product_id"
ALTER TABLE products ADD UNIQUE (product_id);

-- Наиболее распространённые команды:

    -- ADD — добавление ограничения: например, ключа или уникальности
    -- SET — установка значения: например, типа данных
    -- DROP — удаление ограничения
    -- Запрос ALTER устроен таким образом, что в рамках одного обновления можно группировать только одинаковые операции.
    -- В примере выше как раз это показано: один запрос добавляет первичный ключ, а другой обновляет сразу два поля.
    -- Если попробовать объединить их в один ALTER, то СУБД завершит запрос с ошибкой.


----------------------------------------------------

-- Сортировка.
-- Сортировка задаётся с помощью части ORDER BY, за которой следует имя поля, по которому происходит сортировка:
SELECT * FROM users ORDER BY username;

-- База данных — умная штука, она знает, как сравнивать не только числа, но и строки, и даты.
-- Сортировка по датам — крайне частая операция, выглядит она идентично любой другой сортировке:
SELECT * FROM users ORDER BY created_at;

-- Если ничего дополнительно не указывать, то ORDER BY сортирует в прямом порядке — от меньшего к большему.
-- Запрос выше — это сокращённая версия полного запроса с сортировкой: полный запрос включает в себя ASC,
-- который подставляется автоматически, если ничего не указано:

SELECT * FROM users ORDER BY created_at ASC;
-- то же самое что и SELECT * FROM users ORDER BY created_at;

-- Для сортировки в обратном порядке указывается DESC:
SELECT * FROM users ORDER BY created_at DESC;

-- Иногда возникает необходимость сортировать данные сразу по нескольким полям.
-- Этого легко добиться, просто перечисляя поля через запятую:
SELECT * FROM users ORDER BY first_name, created_at;

-- Порядок сортировки в таком случае задаётся для каждого поля индивидуально:
SELECT * FROM users ORDER BY first_name DESC, created_at DESC;
SELECT first_name, created_at FROM users ORDER BY first_name ASC, created_at DESC;

-- У сортировки есть один тонкий момент, связанный с сортировкой полей, содержащих NULL.
-- Если ничего не указано дополнительно, то считается, что NULL больше любого значения.
-- Другими словами, при прямой сортировке они окажутся в конце выборки, а при обратной — в начале.
-- Этим поведением можно управлять с помощью фразы NULLS FIRST:
-- сортируем по возрастанию даты (поле "created_at")
-- поведение по умолчанию:
-- поля, содержащие NULL, идут последними
SELECT * FROM users ORDER BY created_at ASC;

-- сортируем по возрастанию даты (поле "created_at")
-- поля, содержащие NULL, идут первыми
SELECT * FROM users ORDER BY created_at ASC NULLS FIRST;

-- сортируем по убыванию даты (поле "created_at")
-- поля, содержащие NULL, идут последними
SELECT * FROM users ORDER BY created_at DESC NULLS LAST;



----------------------------------------------------

-- Условия (WHERE)
-- Самое простое условие — указание прямого соответствия. Например, выборка по идентификатору:
-- В случае базы данных знак `=` должен восприниматься
-- как математическое равенство, а не присваивание.
SELECT * FROM users WHERE id = 3;

UPDATE users SET first_name = 'Valya' WHERE id = 3;

DELETE FROM users WHERE id = 3;

-- выбрать всех пользователей с идентификатором, НЕ равным трём
SELECT * FROM users WHERE id != 3;

-- Проверка на равенство с NULL
-- Равно NULL:
SELECT * FROM users WHERE first_name IS NULL;
-- Не равно NULL:
SELECT * FROM users WHERE created_at IS NOT NULL;

-- Равенство строк
SELECT * FROM users WHERE first_name = 'sunny';
SELECT * FROM users WHERE first_name = 'Sunny';
-- Выше два разных запроса.
-- По этой причине данные в базе стараются хранить в нормализованном виде. То есть, перед добавлением в БД их приводят,
-- например, к нижнему регистру, и то же самое делают при выборках. Классический пример — email.
-- Его нужно хранить только в нижнем регистре.
-- Кроме точного соответствия, SQL поддерживает и все остальные операции сравнения: > (больше), < (меньше), != (не равно),
-- >= (больше либо равно, "не меньше"), <= (меньше либо равно, "не больше").
SELECT *
  FROM users
  WHERE created_at < '2018-10-05';


----------------------------------------------------

-- Логические операторы
-- В свою очередь все операции можно объединять в цепочки, используя логические операторы OR и AND:
SELECT *
  FROM users
  WHERE created_at > '1998-10-05' AND created_at < '2018-10-05';

-- Для условий диапазонов SQL поддерживает особый формат BETWEEN:
SELECT *
  FROM users
  WHERE created_at BETWEEN '2018-01-01' AND '2018-10-05';
-- Идентично SELECT * FROM users WHERE created_at >= '2018-01-01' AND created_at <= '2018-10-05';

-- IN
SELECT * FROM users WHERE id = 1 OR id = 2 OR id = 5;

-- Страшно представить, во что превратится запрос, если понадобится найти десяток совпадений. К счастью, SQL предлагает другое решение - IN:
SELECT * FROM users WHERE id IN (1, 2, 5);

-- Иногда нужно искать по частичному совпадению: например, проверяя, что строка начинается или заканчивается с определённой
-- последовательности символов. Допустим, мы хотим посмотреть пользователей, имя которых начинается с буквы A:
SELECT * FROM users WHERE first_name LIKE 'A%';
-- Обратите внимание на то, что этот поиск регистрозависимый. Если вы хотите искать БЕЗ учёта регистра, то используйте ILIKE.


--------------------------------------------

-- Лимит (LIMIT)
SELECT * FROM users LIMIT 10;
-- А что, если пользователь, просмотрев первые 10 записей, захочет посмотреть следующие 10? Это обычная ситуация,
-- которая реализуется через пейджинг — специальный механизм, который позволяет перемещаться по страницам.
-- Для его реализации одного LIMIT не достаточно, также понадобится смещение OFFSET:
SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 10;


----------------------------------------------------


-- DISTINCT
-- Предположим, что нам нужно узнать все имена, которые есть у наших пользователей.
-- Самый простой способ сделать это — выполнить запрос не всех полей, а только имени:
-- получить список имён всех пользователей
SELECT first_name FROM users;

-- Избавиться от дублей можно с помощью DISTINCT.
SELECT DISTINCT first_name FROM users;
-- DISTINCT позволяет указывать не одно, а сразу несколько полей:
-- DISTINCT добавляется в запрос только один раз, независимо от того, сколько колонок перечисляется
SELECT DISTINCT first_name, last_name FROM users;

-- В эту выборку попадут все значения с уникальным сочетанием имён и фамилий. Это значит,
-- что имена и фамилии повторяться могут, но пара всегда уникальна. Если в DISTINCT добавить первичный ключ
-- (SELECT DISTINCT id, first_name FROM users), то запрос извлечёт все записи. Такой результат является следствием уникальности первичного ключа.


-- Все записи, уникальные по user_id
SELECT DISTINCT ON (user_id) * FROM topics;

 id | user_id |              title              | body                  |       created_at
----|---------|---------------------------------|-----------------------|------------------------
  2 |       2 | molestiae voluptas velit        | Quod quasi molestiae. | 2019-06-02 23:42:30.688

-- Все title для уникальных user_id
SELECT DISTINCT ON (user_id) title FROM topics;

             title
-------------------------
 molestiae voluptas velit

SELECT DISTINCT user_id, title FROM topics;
-- Такой запрос вернет совершенно другие данные, он вернет все уникальные пары user_id-title
-- То есть здесь возможно повторение user_id в результирующей выборке

SELECT DISTINCT ON (user_id, title) user_id, title FROM topics;
-- Этот запрос равносилен тому, что был выше


-------------------------------------------------


-- Функции
-- Функции, которые что-то считают по таблице, называются агрегатными.
-- К ним относятся нахождение числа записей, суммы значений, среднего арифметического и многое другое.
SELECT COUNT(*) FROM users;

 count
-------
    99
(1 row)

-- COUNT() — функция, которая считает количество записей в выборке. Подчеркну — не в таблице, а в выборке:
SELECT COUNT(*) FROM users WHERE birthday < '2018-10-21';

 count
-------
    91
(1 row)

-- Такой запрос вернёт ровно одну запись с одним значением — количеством строк по указанному условию.

-- Функция COUNT() относится к агрегирующим (агрегатным) функциям. У неё есть несколько форм:

    -- Когда аргументом функции является *, она считает количество строк.
    -- Если в неё передать имя конкретного поля, то она посчитает количество строк, в которых это поле НЕ равно NULL.


-- Max, Min
-- Функции MAX и MIN позволяют находить максимальное и минимальное значение соответственно.
SELECT MAX(birthday) FROM users WHERE gender = 'male';

    max
------------
 2018-12-06
 (1 row)

SELECT MIN(birthday) FROM users WHERE gender = 'female';

    min
------------
 2017-12-08
 (1 row)


-- Sum
-- Функция SUM находит сумму всех значений.
-- Получить сумму всех заказов из таблицы Orders,
-- которые были совершены в 2016 году.
SELECT SUM(amount) FROM orders
  WHERE created_at BETWEEN '2016-01-01' AND '2016-12-31';

-- Avg
-- Функция AVG находит среднее арифметическое всех значений.
-- Получить среднюю стоимость всех заказов из таблицы Orders,
-- которые были совершены в 2016 году.
SELECT AVG(amount) FROM orders
  WHERE created_at BETWEEN '2016-01-01' AND '2016-12-31';


----------------------------------------------------

-- Группировка (GROUP)
-- Типичные задачи, связанные с агрегатными функциями, выглядят так: Вывести общее число топиков для каждого пользователя.
-- Используя только функции, невозможно выполнить данную задачу за один запрос, придётся делать выборку для каждой категории индивидуально:
SELECT COUNT(*) FROM topics WHERE user_id = 3;
SELECT COUNT(*) FROM topics WHERE user_id = 4;
-- ...

-- Если пользователей тысячи (десятки, сотни, миллионы!), то такое решение вопроса не приемлемо в принципе.
-- Подобные задачи возникают настолько часто, что для них существует специальная форма GROUP BY.
-- Группировка, как это ни странно, группирует строки по определённому признаку для выполнения подсчётов внутри каждой группы независимо от других групп.

SELECT user_id, COUNT(*) FROM topics GROUP BY user_id;

 user_id | count
---------+-------
      71 |     1
      80 |     1
      84 |     3
      92 |     1
      60 |     1
      97 |     2
      98 |     1
      44 |     1
      40 |     1
      43 |     1

-- К результатам такой выборки можно применять сортировку и лимитирование:
SELECT user_id, COUNT(*) FROM topics GROUP BY user_id ORDER BY count DESC LIMIT 3;

 user_id | count
---------+-------
      84 |     3
      97 |     2
      57 |     2

-- Сортировка позволяет обращаться не только к полям самой таблицы, но и к вычисленному значению.
-- По умолчанию имя этого "виртуального" поля совпадает с именем функции, но его можно изменить с помощью механизма псевдонимов:
SELECT user_id, COUNT(*) AS topics_count
  FROM topics
  GROUP BY user_id
  ORDER BY topics_count DESC
  LIMIT 3;

-- Псевдонимы создаются не только для агрегатных значений, но и для любых имён, перечисляемых в запросе,
-- переименовываются даже существующие поля. Общая структура задания имени выглядит так: <expression> AS <name>.
SELECT first_name AS name FROM users;

-- Псевдонимы хороши тем, что, если определить их в одном месте, они становятся доступны в других частях SQL запроса:
SELECT first_name AS name FROM users ORDER BY name;


-------------------------------------------
-- INNER JOIN
-- Реляционная алгебра позволяет выполнить эту операцию с помощью соединения JOIN, используя ровно один запрос. Начнём знакомство с JOIN на примере:
-- В выборке участвуют не все поля только для того, чтобы уместить
-- её на экран, а вообще здесь можно использовать `*`
SELECT first_name, title
  FROM users JOIN topics ON users.id = topics.user_id LIMIT 5;

 first_name |            title
------------+------------------------------
 Sean       | beatae voluptatem commodi
 Wyatt      | tempora accusamus nostrum
 Oleta      | eaque fugiat consequatur
 Brandon    | aut exercitationem expedita
 Domenica   | voluptatem soluta similique

-- Результатом данного запроса станет выборка, в которую попали поля обеих таблиц.
-- Здесь соединяются две таблицы: users и topics по условию users.id = topics.user_id. Это важное условие для правильной работы.
-- В нашем примере отношения связаны внешним ключом: соответственно, при джойне этих таблиц нужно явно указать, как мы их соединяем.
-- Общий синтаксис выглядит так: SELECT * FROM table1 JOIN table2 ON table1.id_field_name = table2.id_field_name
-- (на самом деле общая форма сложнее, так как джойнить можно произвольное число таблиц и условий соединения тоже может быть много).

-- JOIN — это сокращенная версия соединения INNER JOIN, то есть внутреннего соединения.

-- В эту выборку попадают только те записи, для которых есть соответствие в другой таблице.
-- Причём, если у одного пользователя пять топиков, то в выборке окажутся все пять строк.
-- Такой запрос имеет смысл делать на странице вывода топиков, что позволит к каждому топику сразу же вывести нужную информацию и о самом пользователе.

-- Запросы с соединениями порождают одну небольшую проблему. В примере выше часть SELECT содержит только те поля,
-- имена которых уникальны среди всех полей обеих таблиц. Соответственно, при выборке не возникает неоднозначностей.
-- Если выполнить этот же запрос со звёздочкой, то в выборку попадут поля, у которых одинаковые названия,
-- что создаст сложности при анализе данных уже в коде приложения. А при выполнении запроса с указанием дублирующихся полей вообще возникнет ошибка:
SELECT id FROM users JOIN topics ON users.id = topics.user_id LIMIT 5;
ERROR:  column reference "id" is ambiguous
LINE 1: SELECT id FROM users JOIN topics ON users.id = topics.user_i...

-- В таких случаях спасают псевдонимы и возможность указывать таблицу для каждого поля:

SELECT users.id AS user_id, topics.id AS topic_id
  FROM users JOIN topics ON users.id = topics.user_id LIMIT 5;

 user_id | topic_id
---------+----------
       9 |        1
      33 |        2
      43 |        3
      49 |        4
      10 |        5
(5 rows)

-- LEFT JOIN
-- LEFT JOIN берёт все данные из одной таблицы и присоединяет к ним данные из другой, если они присутствуют.
-- Если нет, то заполняет их NULL. Чисто технически этот запрос отличается только тем, что добавляется слово LEFT:
SELECT first_name, title FROM users
  LEFT JOIN topics ON users.id = topics.user_id LIMIT 5;

first_name |            title
------------+------------------------------
 Sean       | beatae voluptatem commodi
 Wyatt      | tempora accusamus nostrum
 Mia        |
 Royal      |
 Enos       | et eos dicta

-- LEFT JOIN полезен в тех ситуациях, когда нам нужно работать со всеми данными (возможно, по условию WHERE) одной таблицы
-- и связанными с ними данными, если они есть. Если их нет, то ничего страшного, мы всё равно хотим получить данные из первой таблицы.

-- Этот запрос всё ещё не возвращает нам то, что мы хотели изначально. Но теперь, глядя на эту выборку, как на новое отношение,
-- вы и сами можете сказать, что осталось сделать, чтобы получить пользователей, которые не оставили ни одного топика на Хекслете.
-- Правильно, нужно добавить в выборку условие WHERE:
SELECT COUNT(*)
  FROM users
  LEFT JOIN topics ON users.id = topics.user_id
  WHERE title IS NULL;

 count
-------
    59
(1 row)